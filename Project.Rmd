---
title: "Analisi house price"
author: "Urbani Ludovico, Mohamed Fadhla Mutua, Nicola Battiston, Nicolò Nava"
date: "2024-06-24"
output:
  pdf_document: default
  html_document: default
---

# Importazione delle librerie

``` {r, message = F, warning = F}
for (package in c("ggplot2", "ggcorrplot", "ggpubr", "ggfortify", "dplyr", "tidyr", 
                  "reshape2", "gridExtra", "MASS", "car", "lmtest")) {
    if (!require(package, character.only = T, quietly = T)) {
      install.packages(package, character.only = T)
    }
    
    library(package, character.only = T)
}

plot_theme = theme_minimal() +
    theme(
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.line = element_line(color = "darkgrey"),
        axis.ticks = element_line(color = "black"))
theme_set(plot_theme)
```

# Importazione dei dati

```{r, message = F, warning = F}
HP <- read.csv2(
    "./dataset.csv",
    sep = ",", 
    stringsAsFactors = T,
    row.names=1)

attach(HP)
```

Trasformo le variabili opportune in factor
```{r, message = F, warning = F}
# Alley
HP <- HP %>%
  mutate(Alley = as.character(Alley),
         Alley = replace_na(Alley, "No Alley"))
HP$Alley <- factor(
    HP$Alley, 
    levels = c("Grvl", "Pave", "No Alley"))

# BsmtQual
HP <- HP %>%
  mutate(BsmtQual = as.character(BsmtQual),
         BsmtQual = replace_na(BsmtQual, "No Bsmt"))
HP$BsmtQual <- factor(
    HP$BsmtQual, 
    levels = c("Ex", "Gd", "TA", "Fa", "Po", "No Bsmt"))

# BsmtCond
HP <- HP %>%
  mutate(BsmtCond = as.character(BsmtCond),
         BsmtCond = replace_na(BsmtCond, "No Bsmt"))
HP$BsmtCond <- factor(
    HP$BsmtCond, 
    levels = c("Ex", "Gd", "TA", "Fa", "Po", "No Bsmt"))

# BsmtExposure
HP <- HP %>%
  mutate(BsmtExposure = as.character(BsmtExposure),
         BsmtExposure = replace_na(BsmtExposure, "No Bsmt"))
HP$BsmtExposure <- factor(
    HP$BsmtExposure, 
    levels = c("Gd", "Av", "Mn", "No", "No Bsmt"))

# BsmtFinType1
HP <- HP %>%
  mutate(BsmtFinType1 = as.character(BsmtFinType1),
         BsmtFinType1 = replace_na(BsmtFinType1, "No Bsmt"))
HP$BsmtFinType1 <- factor(
    HP$BsmtFinType1, 
    levels = c("GLQ", "ALQ", "BLQ", "Rec", "LwQ", "Unf", "No Bsmt"))

# BsmtFinType2
HP <- HP %>%
  mutate(BsmtFinType2 = as.character(BsmtFinType2),
         BsmtFinType2 = replace_na(BsmtFinType2, "No Bsmt"))
HP$BsmtFinType2 <- factor(
    HP$BsmtFinType2, 
    levels = c("GLQ", "ALQ", "BLQ", "Rec", "LwQ", "Unf", "No Bsmt"))

# Heating
HP <- HP %>%
  mutate(HeatingQC = as.character(HeatingQC),
         HeatingQC = replace_na(HeatingQC, "No Heating"))
HP$HeatingQC <- factor(
    HP$HeatingQC, 
    levels = c("Ex", "Gd", "TA", "Fa", "Po", "No Heating"))

# FireplaceQu
HP <- HP %>%
  mutate(FireplaceQu = as.character(FireplaceQu),
         FireplaceQu = replace_na(FireplaceQu, "No Fireplace"))
HP$FireplaceQu <- factor(
    HP$FireplaceQu, 
    levels = c("Ex", "Gd", "TA", "Fa", "Po", "No Fireplace"))

# GarageType
HP <- HP %>%
  mutate(GarageType = as.character(GarageType),
         GarageType = replace_na(GarageType, "No Garage"))
HP$GarageType <- factor(
    HP$GarageType, 
    levels = c("2Types", "Attchd", "Basment", "BuiltIn", 
               "CarPort",	"Detchd", "No Garage"))

# GarageFinish
HP <- HP %>%
  mutate(GarageFinish = as.character(GarageFinish),
         GarageFinish = replace_na(GarageFinish, "No Garage"))
HP$GarageFinish <- factor(
    HP$GarageFinish,
    levels = c("Fin", "RFn", "Unf", "No Garage"))

# GarageQual
HP <- HP %>%
  mutate(GarageQual = as.character(GarageQual),
         GarageQual = replace_na(GarageQual, "No Garage"))
HP$GarageQual <- factor(
    HP$GarageQual, 
    levels = c("Ex", "Gd", "TA", "Fa", "Po", "No Garage"))

# GarageCond
HP <- HP %>%
  mutate(GarageCond = as.character(GarageCond),
         GarageCond = replace_na(GarageCond, "No Garage"))
HP$GarageCond <- factor(
    HP$GarageCond, 
    levels = c("Ex", "Gd", "TA", "Fa", "Po", "No Garage"))

# PoolQC
HP <- HP %>%
  mutate(PoolQC = as.character(PoolQC),
         PoolQC = replace_na(PoolQC, "No Pool"))
HP$PoolQC <- factor(
    HP$PoolQC, 
    levels = c("Ex", "Gd", "TA", "No Pool"))

# Fence
HP <- HP %>%
  mutate(Fence = as.character(Fence),
         Fence = replace_na(Fence, "No Fence"))
HP$Fence <- factor(
    HP$Fence, 
    levels = c("GdPrv", "MnPrv", "GdWo", "MnWw", "No Fence"))

# MiscFeature
HP <- HP %>%
  mutate(MiscFeature = as.character(MiscFeature),
         MiscFeature = replace_na(MiscFeature, "No MiscFeature"))
HP$MiscFeature <- factor(
    HP$MiscFeature, 
    levels = c("Elev", "Gar2", "Othr", "Shed", "TenC", "No MiscFeature"))

attach(HP)
```

# Distribuzione dei prezzi delle case

``` {r, warning = F}
SalePrice.summary <- summary(SalePrice)

print(SalePrice.summary)
```

``` {r, warning = F}
ggplot(HP, aes(x = SalePrice)) +
    geom_density() +
    xlab("Prezzo di vendita") +
    ylab("Densità") +
    geom_vline(
        aes(xintercept = SalePrice.summary["1st Qu."], colour = "1° Quantile"), 
        linetype = "dashed") +
    geom_vline(
        aes(xintercept = SalePrice.summary["Mean"], colour = "Media"), 
        linetype = "dashed") +
    geom_vline(
        aes(xintercept = SalePrice.summary["Median"], colour = "Mediana"), 
        linetype = "dashed") +
    geom_vline(
        aes(xintercept = SalePrice.summary["3rd Qu."], colour = "3° Quantile"), 
        linetype = "dashed") +
    labs(colour = "Statistiche") +
    scale_color_manual(
        labels = c("1° Quantile", "3° Quantile", "Media", "Mediana"), 
        values = c("green", "darkgreen", "red", "blue"))
```

``` {r, warning = F}
ggplot(HP, aes(x = SalePrice)) +
    geom_boxplot() +
    xlab("Prezzo di vendita")
```

Possiamo dedurre che la distribuzione è positivamente asimetrica e che la maggior parte del prezzo di vendita è compresa tra 129.975 e 214.000, essendo rispettivamente il 1° e il 3° quantile.
Si può dedurre che sono una piccola parte delle case vendute siano ville di lusso, case lussuose o immobili di alto valore, ma la maggior parte del mercato immobiliare di concentri sulla vendita di piccoli o medi immobili.

# Matrice di correlazione

Prima di tutto identifico le variabili su cui ha senso fare una correlazione con il prezzo
``` {r, warning = F}
Heapmap.vars <- names(HP)

selected_vars <- HP[Heapmap.vars]

convert_to_numeric <- function(x) {
    if (is.factor(x) || is.character(x)) {
        as.numeric(factor(x, levels = unique(x)))
    } else {
        return(x)
    }
}

selected_data <- selected_vars %>% 
    mutate(across(everything(), ~ convert_to_numeric(.)))

selected_data_numeric <- selected_data %>% 
    mutate(across(everything(), ~ as.numeric(as.character(.))))

corHeap <- as.data.frame(round(cor(selected_data_numeric, HP$SalePrice),2))

names(corHeap) <- "SalePrice"

withNA <- rownames(corHeap)[is.na(corHeap$SalePrice)]

for (ele in withNA) {
    HP_lotfrontage <- selected_data_numeric[[ele]][
        which(!is.na(selected_data_numeric[[ele]]))]
    HP_lotfrontageSALE <- selected_data_numeric$SalePrice[
        which(!is.na(selected_data_numeric[[ele]]))]
    corHeap[ele,"SalePrice"] <- cor(HP_lotfrontageSALE,HP_lotfrontage)
}
```

ora si può visualizzare il vettore di correlazione come
``` {r, warning = F}
length_corHeap <- c(
    ceiling(NROW(corHeap) / 4), 
    ceiling(NROW(corHeap) / 2), 
    ceiling(3 * NROW(corHeap) / 4))

first_half_corHeap <- as.data.frame(corHeap[1:length_corHeap[1],])
names(first_half_corHeap) <- "SalePrice"
first_half_corHeap <- rbind.data.frame(data.frame(SalePrice = 0), first_half_corHeap)
rownames(first_half_corHeap) <- c(
    "0", rownames(corHeap)[1:length_corHeap[1]])

second_half_corHeap <- as.data.frame(corHeap[(length_corHeap[1]+1):length_corHeap[2], ])
names(second_half_corHeap) <- "SalePrice"
second_half_corHeap <- rbind.data.frame(data.frame(SalePrice = 0), second_half_corHeap)
rownames(second_half_corHeap) <- c(
    "0", rownames(corHeap)[(length_corHeap[1]+1):length_corHeap[2]])

third_half_corHeap <- as.data.frame(corHeap[(length_corHeap[2]+1):length_corHeap[3],])
names(third_half_corHeap) = "SalePrice"
third_half_corHeap <- rbind.data.frame(data.frame(SalePrice = 0), third_half_corHeap)
rownames(third_half_corHeap) <- c(
    "0", rownames(corHeap)[(length_corHeap[2]+1):length_corHeap[3]])

fourth_half_corHeap <- as.data.frame(corHeap[(length_corHeap[3]+1):NROW(corHeap),])
names(fourth_half_corHeap) = "SalePrice"
fourth_half_corHeap <- rbind.data.frame(data.frame(SalePrice = 0), fourth_half_corHeap)
rownames(fourth_half_corHeap) <- c(
    "0", rownames(corHeap)[(length_corHeap[3]+1):NROW(corHeap)])

p1 <- ggcorrplot(
    first_half_corHeap, 
    type = "lower",
    lab = TRUE, 
    lab_size = 2.3, 
    show.legend = F) +
    theme(
        axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7))
p2 <- ggcorrplot(
    second_half_corHeap,
    type = "lower",
    lab = TRUE, 
    lab_size = 2.3, 
    show.legend = F) +
    theme(
        axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7))
p3 <- ggcorrplot(
    third_half_corHeap,
    type = "lower",
    lab = TRUE, 
    lab_size = 2.3, 
    show.legend = T) +
    theme(
        axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7))
p4 <- ggcorrplot(
    fourth_half_corHeap,
    type = "lower",
    lab = TRUE, 
    lab_size = 2.3, 
    show.legend = F) +
    theme(
        axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7))

get_legend <- function(myplot) {
    tmp <- ggplot_gtable(ggplot_build(myplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)
}
legend <- get_legend(p3)
p3 <- p3 + theme(legend.position = "none")

grid.arrange(
    arrangeGrob(p1, p2, p3, p4, nrow = 4),
    legend,
    ncol = 2,
    widths = c(4, 1))
```

## Variabili calcolate

Prendo le variabili escluse e le variabili che nealla heatmap hanno una bassa correlazione e provo a creare delle variabili calcolate che potrebbero essere correlate a SalePrice. 
Ad esempio variabili quantitative o qualitative che hanno valori NA o 0 per indicare l'assenza di quella caratteristica le trasformo in variabili booleane.

```{r, message = F, warning = F}
HP_Excluded = HP

# Alley
recode_map <- c(
    "Grvl" = "T",
    "Pave" = "T",
    "No Alley" = "F")
HP_Excluded <- HP_Excluded %>%
    mutate(Alley = as.character(Alley),
           AlleyExists = dplyr::recode(Alley, !!!recode_map))
HP_Excluded$AlleyExists <- factor(HP_Excluded$AlleyExists, levels = c("F", "T"))

# LotShape
recode_map <- c(
    "Reg" = "Regular",
    "IR1" = "Irregular",
    "IR2" = "Irregular",
    "IR3" = "Irregular")
HP_Excluded <- HP_Excluded %>%
    mutate(LotShapeReduced = dplyr::recode(LotShape, !!!recode_map))

# YearBuilt
current_year <- as.integer(format(Sys.Date(), "%Y"))
HP_Excluded$HouseAge <- current_year - YearBuilt

# TotalBath
HP_Excluded$TotalBath <- FullBath + HalfBath + BsmtFullBath + BsmtHalfBath

# MSZoning
recode_map <- c(
    "A" = "Agriculture",
    "C" = "Commercial",
    "FV" = "Residential",
    "I" = "Industrial",
    "RH" = "Residential",
    "RL" = "Residential",
    "RP" = "Residential",
    "RM" = "Residential")
HP_Excluded <- HP_Excluded %>%
    mutate(MSZoningReduced = dplyr::recode(MSZoning, !!!recode_map))

# GarageType
recode_map <- c(
    "2Types" =	"T",
    "Attchd" =	"T",
    "Basment" =	"T",
    "BuiltIn" =	"T",
    "CarPort" =	"T",
    "Detchd" =	"T",
    "No Garage" = "F")
HP_Excluded <- HP_Excluded %>%
    mutate(GarageType = as.character(GarageType),
           GarageExists = dplyr::recode(GarageType, !!!recode_map))
HP_Excluded$GarageExists <- factor(HP_Excluded$GarageExists, levels = c("F", "T"))

# Utilities
recode_map <- c(
    "AllPub" = "All",
    "NoSewr" = "Some",
    "NoSeWa" ="Some",
    "ELO" =	"Some")
HP_Excluded <- HP_Excluded %>%
    mutate(UtilitiesReduced = dplyr::recode(Utilities, !!!recode_map))

# OverallCond
recode_map <- c(
    "10" = "Excellent",
    "9"	 = "Excellent",
    "8" =	"Good",
    "7"	= "Good",
    "6" =	"Average",	
    "5" =	"Average",
    "4" = "Average"	,
    "3" =	"Poor",
    "2" =	"Poor",
    "1" =	"Poor"
)
HP_Excluded <- HP_Excluded %>%
    mutate(OverallCondReduced = dplyr::recode(OverallCond, !!!recode_map))

# BsmtCond
recode_map <- c(
    "Ex" =	"T",
    "Gd" =	"T",
    "TA" =	"T",
    "Fa" =	"T",
    "Po" =	"T",
    "No Bsmt" = "F")
HP_Excluded <- HP_Excluded %>%
    mutate(BsmtCond = as.character(BsmtCond),
           BsmtExists = dplyr::recode(BsmtCond, !!!recode_map))
HP_Excluded$BsmtExists <- factor(HP_Excluded$BsmtExists, levels = c("F", "T"))

# Fence
recode_map <- c(
    "GdPrv" =	"T",
    "MnPrv" =	"T",
    "GdWo" =	"T",
    "MnWw" =	"T",
    "No Fence" = "F"
)
HP_Excluded <- HP_Excluded %>%
    mutate(Fence = as.character(Fence),
           FenceExists = dplyr::recode(Fence, !!!recode_map))
HP_Excluded$FenceExists <- factor(HP_Excluded$FenceExists, levels = c("F", "T"))

# MiscFeature
recode_map <- c(
    "Elev" =	"T",
    "Gar2" =	"T",
    "Othr" =	"T",
    "Shed" =	"T",
    "TenC" =	"T",
    "No MiscFeature" = "F"
)
HP_Excluded <- HP_Excluded %>%
    mutate(MiscFeature = as.character(MiscFeature),
           MiscFeatureExists = dplyr::recode(MiscFeature, !!!recode_map))
HP_Excluded$FenceExists <- factor(HP_Excluded$FenceExists, levels = c("F", "T"))
```

ora procedo a metterle in correlazione con SalePrice in un heatmap
```{r, warning = F}
vars <- c("SalePrice", "AlleyExists", "LotShapeReduced", "HouseAge", "MSZoningReduced", 
          "GarageExists", "UtilitiesReduced", "OverallCondReduced", 
          "BsmtExists", "FenceExists", "MiscFeatureExists", "TotalBath")

excludevar <- HP_Excluded[vars]

selected_data <- excludevar %>%
    mutate(across(everything(), ~ convert_to_numeric(.)))

selected_data_numeric <- selected_data %>%
    mutate(across(everything(), ~ as.numeric(as.character(.))))

corHeap_excluded <- as.data.frame(
    round(cor(selected_data_numeric, HP_Excluded$SalePrice), 2))
names(corHeap_excluded) <- "SalePrice"

ggcorrplot(corHeap_excluded, type = "lower", lab = TRUE, lab_size = 2.5) + 
    theme(
        axis.text.x = element_text(size = 9),
        axis.text.y = element_text(size = 9))
```

## Variabile correlate

Filtro le variabili che hanno correlazione con SalePrice >=0.4
```{r, results = F, message = F, warning = F}
totalCorHeap = rbind.data.frame(
    subset(corHeap, subset = rownames(corHeap) != "SalePrice"), 
    subset(corHeap_excluded, subset = rownames(corHeap_excluded) != "SalePrice"))

ggarrange(
    plotlist = lapply(
        rownames(totalCorHeap)[abs(totalCorHeap) >= 0.4],
        function (var) {
            plt <- ggplot(HP, aes(x = HP_Excluded[[var]], y = SalePrice)) +
                xlab(var)
            
            if (is.factor(HP[[var]])) {
                plt <- plt + geom_boxplot()
            } else {
                plt <- plt + geom_point()
            }
            
            plot(plt)
        }),
    ncol = 2,
    nrow = 1,
    widths = c(1, 1)
)
```

# Analisi bivariata

## Funzioni di analisi

Visto che la variabile target SalePrice è quantitativa, distinguo due casi:
1. la seconda variabile è qualitativa:

```{r, warning = F}
analysis.qualitative <- function(target, 
                                 second_var, 
                                 horizontal = F, 
                                 target.lab = "prezzo di vendita", 
                                 second_var.lab = "seconda variabile") {
    df <- subset(data.frame(target, second_var), !is.na(second_var))
    
    test <- aov(target ~ second_var)
    p <- summary(test)[[1]][["Pr(>F)"]][1]
    
    plt <- ggplot(
        df,
        aes(
            x = if (horizontal) target else second_var, 
            y = if (horizontal) second_var else target)) +
    geom_violin(
        trim = F, 
        draw_quantiles = c(0.25, 0.5, 0.75)) +
    stat_summary(
        fun = "mean",
        geom = "point",
        color = "red",
        fill = "red",
        shape = 20,
        size = 2) +
    labs(
        title = paste(target.lab, "VS", second_var.lab, sep = " "),
        subtitle = paste("Anova p-value = ", signif(p, 3), sep = ""),
        x = if (horizontal) target.lab else second_var.lab,
        y = if (horizontal) second_var.lab else target.lab)
    
    plot(plt)
    
    return (signif(p, 3))
}
```

2. la seconda variabile è quantitativa:

```{r, warning = F}
analysis.quantitative <- function(target, 
                                  second_var, 
                                  horizontal = F, 
                                  target.lab = "prezzo di vendita", 
                                  second_var.lab = "seconda variabile") {
    mod <- lm(target ~ second_var)
    p <- summary(mod)$coefficients[2,4]
    
    plt <- ggplot(
        data.frame(target, second_var),
        aes(
            x = if (horizontal) target else second_var, 
            y = if (horizontal) second_var else target)) +
    geom_point(size = 1) +
    geom_abline(
        intercept = coef(mod)[1], 
        slope = coef(mod)[2],
        color = "red") +
    labs(
        title = paste(target.lab, "VS", second_var.lab, sep = " "),
        subtitle = paste("Linear model p-value = ", signif(p, 3), sep = ""),
        x = if (horizontal) target.lab else second_var.lab,
        y = if (horizontal) second_var.lab else target.lab)
    
    plot(plt)
    
    return (signif(p, 3))
}
```

## Analisi della qualità complessiva delle case

``` {r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, factor(OverallQual, levels = 1:10),
    second_var.lab = "qualità di costruzione"
)
```

Con un p-value di `r mod` si deduce che più la qualità di costruzione aumenta, più il prezzo tende a aumentare. È possibile che questo sia dovuto al fatto che le persone associano alla qualità un prezzo superiore. Alla condizione "Very Excellent" si puo osservare una grande varianza, questo puo essere dovuta al fatto che ci sono pocchi dati ma anche che valutare una casa diventa piu difficile.

## Analisi dell'anno di costruzione

``` {r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, YearBuilt,
    second_var.lab = "anno di costruzione"
)

YearBuilt.factor <- cut(
    YearBuilt, 
    breaks = c(min(YearBuilt), 1910, 1950, 1980, 2000, max(YearBuilt)),
    labels = c(paste(min(YearBuilt), "-1910", sep = ""), 
               "1910-1950", "1950-1980", "1980-2000", 
               paste("2000-", max(YearBuilt), sep = "")),
    include.lowest = T)

mod2 <- analysis.qualitative(
    SalePrice, YearBuilt.factor,
    second_var.lab = "anno di costruzione"
)
```

Con un p-value di `r mod` si nota che più le case sono recenti, più il prezzo tende a crescere. Ma le case costruite prima del 1910/1920, quindi le case ritenute storiche, continuano a manterere un costo di vendita abbastanza alto.

## Analisi dell'anno di conclusione degli ultimi lavori

``` {r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, YearBuilt,
    second_var.lab = "ultimi lavori(anno)"
)
```

Con un p-value di `r mod` si nota che più gli ultimi lavori di ristrutturazione (o di costruzione nel caso non siano state ristrutturate) siano recenti, più il prezzo tende a crescere. Questo è dovuto al fatto che, più una casa è in vuole condizioni dopo dei lavori, meno soldi richiederà per essere mantenuta.

## Analisi dell'area di rivestimento in muratura

``` {r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice[MasVnrArea != 0], MasVnrArea[MasVnrArea != 0],
    second_var.lab = "area di rivestimento in muratura"
)
```

Con un p-value di `r mod` si nota che più la superificie rivestita di muratura è ampia, più il prezzp delle case tende a crescere. Questo in quanto il rivestimento in muratura tende a preservare meglio le condizioni delle pareti nel tempo.

## Analisi del tipo di fondamenta

``` {r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, Foundation,
    second_var.lab = "tipo di fondamenta"
)
```

Con un p-value di `r mod` si nota che le case con delle fondamenta in calcestruzzo gettato in opera, tendono ad avere un prezzo più alto.

## Analisi dell'area del seminterrato

``` {r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, TotalBsmtSF,
    second_var.lab = "area del seminterrato"
)
```

Con un p-value di `r mod` si nota che le case con un ampio seminterrato tendono ad avere un prezzo più alto rispetto alle altre.
Nella società americana è comune adibire i seminterrati come spazi di svago e di relax, quindi una casa con un ampio seminterrato ha una maggiore domanda di acquisto.

## Analisi della qualità del riscaldamento

``` {r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, HeatingQC,
    second_var.lab = "qualità del riscaldamento"
)
```

Con un p-value di `r mod` si nota che più la qualità del riscaldamento è alta e più il prezzo della casa di alza. Inoltre la maggioranza delle case con il prezzo più alto rientrano nella fascia migliore di riscaldamento.

## Analisi dell'area del piano terra

``` {r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, X1stFlrSF,
    second_var.lab = "area del piano terra"
)
```

Con un p-value di `r mod` si nota che più la metratura del piano terra è elevata, più il prezzo della casa tende a salire.

## Analisi dell'area dell'area abitabile

```{r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, GrLivArea,
    second_var.lab = "area dell'area abitabile"
)
```

Con un p-value di `r mod` si nota che più l'area del Piano terra aumenta, più il prezzo tende ad aumentare. È possibile che questo sia dovuto al fatto che le persone associano a piu bagni un prezzo superiore. Si nota oltre che piu l'area aumenta, piu l'incertezza su quale prezzo attribuire alla casa.

## Analisi del numero di bagni

```{r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, as.factor(FullBath),
    horizontal = F,
    second_var.lab = "numero di bagni"
)
```

Con un p-value di `r mod` si deduce che più bagni si ha, più il prezzo tende a aumentare. È possibile che questo sia dovuto al fatto il numero di bagni sia direttamente proporzionale alle dimensioni della casa.

## Analisi del numero di stanze sopra il terreno

```{r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, as.factor(TotRmsAbvGrd),
    horizontal = F,
    second_var.lab = "numero di stanze"
)
```

Con un p-value di `r mod` si deduce che più stanze si ha, più il prezzo tende a aumentare. È possibile che questo sia dovuto al fatto che le persone associano a più stanze delle famiglie più numerose.
Si puo osservare degli outlier sulle 2 e 14 stanze dovute alle mancanza dei dati (esiste un solo dato per ognuna).

## Analisi del numero di camini

```{r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, as.factor(Fireplaces),
    horizontal = F,
    second_var.lab = "numero di camini"
)
```

Con un p-value di `r mod` si deduce che più camini si ha, più il prezzo tende a aumentare.

## Analisi della qualità dei camini

```{r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, as.factor(FireplaceQu),
    horizontal = F,
    second_var.lab = "qualità del camini"
)
```

Con un p-value di `r mod` si deduce che al diminuire della qualità dei camini, più il prezzo tende a diminuire. È possibile che questo sia dovuto al fatto che le persone associano alla qualità dei camini una classe energetica superiore e quindi un prezzo maggiore. 
In particolare si nota che le persone associano alle case senza camini lo stesso prezzo delle case con stato peggiore.

## Analisi dell'anno di costruzione del garage

```{r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, GarageYrBlt,
    horizontal = F,
    second_var.lab = "anno di costruzione del garage"
)
```

Con un p-value di `r mod` si deduce che più è nuovo il garage, più il prezzo tende ad aumentare. 
Dato il fatto che la società americana si basa sul petrolio e sui mezzo a motori, il possedere un garage nuovo e/o di buona qualità, costituisca un punto di forza nella vendita di una casa.

## Analisi del numero di posti auto nel garage

```{r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, as.factor(GarageCars),
    horizontal = F,
    second_var.lab = "numero di auto"
)
```

Con un p-value di `r mod` si deduce che più auto che possono stare nel garage, più il prezzo tende ad aumentare. Come nel punto precedente, nei nuclei familiari americani il numero medio di automobili è superiore a quello degli altri paesi, quindi questo comporta una domanda di garage più ampi.

## Analisi dell'area del garage

```{r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, GarageArea,
    horizontal = F,
    second_var.lab = "area del garage"
)
```

Con un p-value di `r mod` si deduce che più grande è il garage, più il prezzo tende ad aumentare. 
Come nel punto precedente, il numero di automobili è direttamente proporzionale alla metratura del garage, quindi le conclusioni sono le stesse.
Si nota che con un garage di 0m^2, quindi nessun garage, il prezzo tende ad essere minore.

## Analisi dell'età delle case

``` {r, message = F, warning = F}
mod <- analysis.quantitative(
    SalePrice, HP_Excluded$HouseAge,
    second_var.lab = "età della casa"
)
```

Con un p-value di `r mod` si deduce che più la casa venduta è vecchia, più il prezzo tende a scendere. È possibile che questo sia dovuto al fatto che quando una casa si deteriora, i proprietari tendano a venderla per poco invece di ristrutturarla.

## Analisi del numero di bagni

```{r, message = F, warning = F}
mod <- analysis.qualitative(
    SalePrice, as.factor(HP_Excluded$TotalBath),
    horizontal = F,
    second_var.lab = "numero di bagni"
)
```

Con un p-value di `r mod` si deduce che più i numeri di bagni aumenta, più il prezzo tende a aumentare. Il numero di bagni solitamente è proporzionale alla grandezza di una casa e una casa più grande ha un costo maggiore.

# Analisi multivariata

## Analisi della qualità complessiva con l'anno degli ultimi lavori
```{r, message = F, warning = F}
ggplot(HP, aes(x = YearRemodAdd, y = log(SalePrice), color = factor(OverallQual))) +
    geom_point() +
    labs(x = "ultimi lavori (anno)", 
         y = "prezzo di vendita", 
         color = "Qualità complessiva") +
    theme_minimal()
```

Dal grafico sovrastante possiamo notare che più gli ultimi lavori effettuti sulle abitazioni è recente, più le abitazioni hanno una qualità complessiva migliore, di conseguenza anche il prezzo è maggiore.
Inoltre possiamo notare che a partire dall'inizio del nuovo millennio c'è stato un notevole riguardo alla qualità complessiva dell'abitazione.
Infine possiamo notare delle fasce di prezzo che sono composte principalmente da un colore solo, il che ci può far dedurre che sia la qualità generale dell'abitazione sia la data degli ultimi lavori sulla casa incidono sul prezzo in modo significativo.

## Analisi della qualità dei camini con l'anno degli ultimi lavori

```{r, message = F, warning = F}
ggplot(HP, aes(x = YearRemodAdd, y = log(SalePrice), color = factor(HeatingQC))) +
    geom_point() +
    labs(x = "ultimi lavori eseguiti", 
         y = "prezzo di vendita", 
         color = "Qualità del riscaldamento") +
    theme_minimal()
```

Da questo grafico, invece, notiamo che il prezzo dell'abitazione non ha fasce distinte di colore, ma si si evidenza un netto miglioramento delle condizioni del riscaldamento dall'inizio del 1990 circa. Con una qualità del riscaldamento che tende ad eccellente nella maggior parte delle case che sono state ristrutturate o costruite negli ultimi anni.

## Analisi del tipo di fondamenta con l'anno degli ultimi lavori

```{r, message = F, warning = F}
ggplot(HP, aes(x = YearBuilt, y = SalePrice, color = Foundation)) +
    geom_point() +
    labs(x = "anno di costruzione", 
         y = "prezzo di vendita", 
         color = "Fondamenta") +
    theme_minimal()
```

In questo grafico si evidenzia rispetto all'anno di costruzione anche il tipo di fondamenta utilizzate per la costruzione della casa.
Come nell'analisi precedente non si evidenziano fasce evidenti, quindi il prezzo di vendita della casa non viene influenzato dalla tipologia di fondamenta utilizzate, ma si può vedere che le tipologia di fondamenta sono in relazione ad un periodo storico, ad esempio recentemente si utilizzano principalmente quelle in calcestruzzo colato, mentre prima del 1980 erano più di moda altre tecniche.

## Analisi dell'area sopra il seminterrato con il numero totale di stanze

```{r, message = F, warning = F}
ggplot(HP, aes(x = GrLivArea, y = SalePrice, color = factor(TotRmsAbvGrd))) +
    geom_point() +
    labs(x = "area totale", 
         y = "prezzo di vendita", 
         color = "Numero di stanze") +
    theme_minimal()
```

Dal grafico possiamo notare che all'aumentare dell'area abitabile c'è anche un aumento del numero delle camere. Questo aumento è più distribuito, meno evidente rispetto alle tecniche del precedente grafico. Inoltre, con l'aumento dell'area totale della casa, c'è anche un significativo aumento del prezzo di vendita.

## Analisi dell'area dell'area abitabile con il numero di bagni

```{r, message = F, warning = F}
ggplot(HP, aes(x = GrLivArea, y = log(SalePrice), color = factor(FullBath))) +
    geom_point() +
    labs(x = "metratura piano terra", 
         y = "prezzo di vendita",
         color = "Numero di bagni") +
    theme_minimal()
```

Nel grafico sovrastante si può notare che all'aumentare dell'area abitabile c'è anche un aumento del numero dei bagni completi all'interno della casa. Con completi si intendono i bagni non di servizio.
C'è anche un evidente aumento di prezzo annesso, che probabilmente è dovuto al fatto che all'aumento del numero di bagni, aumenta anche la metratura della casa.

## Analisi dell'area con l'anno di costruzione dei garage

```{r, message = F, warning = F}
HP$GarageArea.cut <- cut(
    HP$GarageArea, 
    breaks = c(min(HP$GarageArea), 200, 400, 600, 800, 1000, max(HP$GarageArea)), 
    labels = c("0-200", "201-400", "401-600", "601-800", "801-1000", "1001-1418"))

ggplot(HP, aes(x = GarageYrBlt, y = SalePrice, color = GarageArea.cut)) +
    geom_point(na.rm = T) +
    labs(x = "anno di costruzione del garage", 
         y = "prezzo di vendita", 
         color = "Area abitabile") +
    scale_color_discrete(na.translate = F) +
    theme_minimal()
```

Dal grafico possiamo notare un grande aumento dei prezzi delle case con un recente anno di costruzione del garage. Inoltre possiamo notare che sempre le case con il garage costruito recentemente hanno mediamente una metratura del piano terra più grande.

## Analisi della qualità dei caminetti con l'anno degli ultimi lavori

```{r, message = F, warning = F}
ggplot(HP, aes(x = YearRemodAdd, y = SalePrice, color = factor(FireplaceQu))) +
    geom_point() +
    labs(x = "ultimi lavori eseguiti (anno)", 
         y = "prezzo di vendita", 
         color = "Qualità camini") +
    scale_color_discrete(na.translate = F) +
    theme_minimal()
```

Dal grafico sovrastante si può evidenziare che, come con il riscaldamento, anche in questo caso la qualità dei caminetti è mediamente in leggero aumento, in modo meno significativo. Mentre per il prezzo di vendita non ci sono delle fasce di prezzo differenti per qualità dei caminetti. Dunque possiamo dedurre che la qualità del caminetto non incide significativamente sul prezzo di vendita.

## Analisi dell'anno di costruzione del garage con l'anno degli ultimi lavori

```{r, message = F, warning = F}
year_gap <- cut(
    HP$YearRemodAdd, 
    breaks = c(min(HP$YearRemodAdd), 1980, 2000, max(HP$YearRemodAdd)),
    labels = c(paste(min(HP$YearRemodAdd), "-1980", sep = ""), 
               "1980-2000", 
               paste("2000-", max(HP$YearRemodAdd), sep = "")),
    include.lowest = T)

ggplot(HP, aes(x = GarageYrBlt, y = SalePrice, color = factor(year_gap))) +
    geom_point() +
    labs(x = "anno di costruzione del garage", 
         y = "prezzo di vendita", 
         color = "Ultimi lavori (anno)") +
    scale_color_discrete(na.translate = F) +
    theme_minimal()
```

Nel grafico si può notare, come con le fondamenta, delle distinzioni per epoche, il garage soprattutto negli ultimi decenni è stato costruito in concomitanza con gli ultimi lavori effettuati.

# Analisi di regressione

## Data preprocessing

### Gestione dei valori mancanti

```{r, message = F, warning = F}
for(col in names(HP)) {
    if (is.numeric(HP[[col]])) {
        HP[[col]][is.na(HP[[col]])] <- mean(HP[[col]], na.rm = TRUE)
    } else {
        HP[[col]][is.na(HP[[col]])] <- as.character(sort(table(HP[[col]])[1]))
    }
}
```

### Identificazione e rimozione dei valori categorici singoli

```{r, message = F, warning = F}
categorical_vars <- names(HP)[sapply(data, function(x) is.factor(x) | is.character(x))]
single_level_vars <- categorical_vars[
    unlist(sapply(HP[categorical_vars], function(x) length(unique(x)) == 1))]

HP <- HP[, !names(HP) %in% single_level_vars]

categorical_vars <- names(HP)[sapply(HP, function(x) is.factor(x) | is.character(x))]
HP[categorical_vars] <- lapply(HP[categorical_vars], as.factor)
```

## Analisi di correlazione

```{r, message = F, warning = F}
numericVars <- which(sapply(HP, is.numeric))
numericData <- HP[, numericVars]
correlations <- cor(numericData, use = "pairwise.complete.obs")
correlationWithSalePrice <- sort(correlations[, 'SalePrice'], decreasing = TRUE)
topNumericPredictors <- names(correlationWithSalePrice)[2:11]
```

## Selezione delle feature

```{r, message = F, warning = F}
keyCategoricalVars <- c("Neighborhood", "BldgType", "HouseStyle", "OverallQual")
keyCategoricalVars <- keyCategoricalVars[keyCategoricalVars %in% names(HP)]
encoded_data <- data.frame(model.matrix(~.-1, HP))
encoded_categoricalVars <- grep(
    paste(keyCategoricalVars, collapse="|"), names(encoded_data), value=TRUE)
selected_predictors <- c(topNumericPredictors, encoded_categoricalVars)
X_selected <- encoded_data[, selected_predictors]
y <- encoded_data$SalePrice
```

## Regressione con STEPWISE e AIC

```{r, results = "hide", message = F, warning = F}
simple.model <- lm(y ~ ., data = X_selected)
stepwise.model <- stepAIC(simple.model, direction = "both", trace = TRUE)
```
```{r, message = F, warning = F}
summary(stepwise.model)
```

## Diagnostiche

### Valori dei residui vs fitted

```{r, message = F, warning = F}
residuals <- resid(stepwise.model)
fitted_values <- fitted(stepwise.model)

ggplot() +
    geom_point(aes(x = fitted_values, y = residuals), color = "blue") +
    geom_hline(yintercept = 0,
               color = "red",
               linetype = "dashed") +
    ggtitle("Residuals vs Fitted Values") +
    xlab("Fitted Values") +
    ylab("Residuals")
```

### Q-Q Plot dei residui

```{r, message = F, warning = F}
ggplot() +
    geom_qq(aes(sample = residuals)) +
    geom_qq_line(aes(sample = residuals), color = "red") +
    ggtitle("Q-Q Plot dei residui")
```

### Resudui standard, leva e distanza di Cook

```{r, message = F, warning = F}
autoplot(stepwise.model, which = 1:6)
```

in questo primo tentativo di regressione abbiamo ottenuto un R^2 = 0.82, quindi siamo riusciti a spiegare l'82% della variabilità di y (salesprice), il che è un ottimo risultato di partenza, in tutte le regressioni sono state prese le prime 10 variabili piu' correlate a salesprice, unite alle variabili categoriche "Neighborhood", "BldgType", "HouseStyle", "OverallQual" convertite con one hot encoding, in quanto mi sembravano molto importanti. Il modello poi ha trovato in numero corretto di variabili con un p-value basso, che spiegano in maniera buona salesprice.
dal grafico scatter dei residui si nota che nella parte destra si forma un pattern a "funnel" , che si potrebbe spigare col fatto che c'è della non linearità, o degli outlier che influenzano i risultati del modello.
Si nota subito che il valore 1299 del dataset ha un alto valore di Crook, e un alta leva, quindi è opportuno investigarlo.
Da investigazioni sul dato emerge che il fatto che il SaleCondition di quell ossevazione è  "Partial", il che s'ignifica che le caratteristiche della casa erano state rilevate quando essa era in fase di costruzione, percio' ho rimosso le oservazioni col valore di SaleCondition "Partial", in quanto disturbavano i parametri del modello, e non possiamo sapere con certezza se i parametri di quella casa sono affidabili per spiegare il saleprice che cerchiamo di predire.

## Analysis del dataset senza i SaleCondition "Partial"

```{r, results = "hide", message = F, warning = F}
HP_no_partial <- HP[HP$SaleCondition != "Partial",]
HP_no_partial$Id <- NULL

categorical_vars <-
    names(HP_no_partial)[sapply(HP_no_partial, function(x)
        is.factor(x) | is.character(x))]
single_level_vars <-
    categorical_vars[sapply(HP_no_partial[categorical_vars], function(x)
        length(unique(x)) == 1)]
HP_no_partial <-
    HP_no_partial[,!names(HP_no_partial) %in% single_level_vars]
categorical_vars <-
    names(HP_no_partial)[sapply(HP_no_partial, function(x)
        is.factor(x) | is.character(x))]
HP_no_partial[categorical_vars] <-
    lapply(HP_no_partial[categorical_vars], as.factor)
numericVars <- which(sapply(HP_no_partial, is.numeric))
numericData <- HP_no_partial[, numericVars]
correlations <- cor(numericData, use = "pairwise.complete.obs")
correlationWithSalePrice <-
    sort(correlations[, 'SalePrice'], decreasing = TRUE)
topNumericPredictors <- names(correlationWithSalePrice)[2:11]
keyCategoricalVars <-
    c("Neighborhood", "BldgType", "HouseStyle", "OverallQual")
keyCategoricalVars <-
    keyCategoricalVars[keyCategoricalVars %in% names(HP_no_partial)]
encoded_data <- data.frame(model.matrix( ~ . - 1, HP_no_partial))
encoded_categoricalVars <-
    grep(paste(keyCategoricalVars, collapse = "|"),
         names(encoded_data),
         value = TRUE)
selected_predictors <-
    c(topNumericPredictors, encoded_categoricalVars)
X_selected <- encoded_data[, selected_predictors]
y <- encoded_data$SalePrice
simple.model <- lm(y ~ ., data = X_selected)
stepwise.model <-
    stepAIC(simple.model, direction = "both", trace = TRUE)
```
```{r, message = F, warning = F}
summary(stepwise.model)
```

### Valori dei residui vs fitted (senza Partial Sales)

```{r, message = F, warning = F}
residuals <- resid(stepwise.model)
fitted_values <- fitted(stepwise.model)

ggplot() +
    geom_point(aes(x = fitted_values, y = residuals), color = "blue") +
    geom_hline(yintercept = 0,
               color = "red",
               linetype = "dashed") +
    ggtitle("Residuals vs Fitted Values (Without Partial Sales)") +
    xlab("Fitted Values") +
    ylab("Residuals")
```

### Q-Q Plot dei residui (senza Partial Sales)

```{r, message = F, warning = F}
ggplot() +
    geom_qq(aes(sample = residuals)) +
    geom_qq_line(aes(sample = residuals), color = "red") +
    ggtitle("Q-Q Plot dei residui (Without Partial Sales)")
```

### Resudui standard, leva e distanza di Cook (senza Partial Sales)

```{r, message = F, warning = F}
autoplot(stepwise.model, which = 1:6)
```

In questo secondo tentativo di regressione abbiamo ottenuto un R^2 = 0.85, quindi siamo riusciti a spiegare l'85% della variabilità di y (salesprice), il che è un ottimo incremento, che conferma che il nostro modello è adatto per spiegare le case con condizioni di vendita non "Partial", 
dal grafico scatter dei residui si nota che nella parte destra il pattern precedente si è affievolito, pero' viene mostrata un esplosione dei residui con l'aumentare di y, il che implica che il modello non riesce a generalizzare bene per alti prezzi di saleprice , per tale motivo ho deciso di tentare successivamente una regressione con log(y) come variabile target, per cercare di catturare anche questo tipo di curva dei residui e mitigarla. Il QQ plot dei residui mostra che sulle code si hanno delle deviazioni dalla normalità, presupponendo presenza di outlier o non-linearita.

## Analisi con Log(y) del Dataset senza Partial Sales

```{r, results = "hide", message = F, warning = F}
y_transformed <- log(y)
simple.model <- lm(y_transformed ~ ., data = X_selected)
stepwise.model <-
    stepAIC(simple.model, direction = "both", trace = TRUE)
residuals <- resid(stepwise.model)
fitted_values <- fitted(stepwise.model)

ggplot() +
    geom_point(aes(x = fitted_values, y = residuals), color = "blue") +
    geom_hline(yintercept = 0,
               color = "red",
               linetype = "dashed") +
    ggtitle("Residuals vs Fitted Values") +
    xlab("Fitted Values") +
    ylab("Residuals")

ggplot() +
    geom_qq(aes(sample = residuals)) +
    geom_qq_line(aes(sample = residuals), color = "red") +
    ggtitle("Q-Q Plot dei residui")

autoplot(stepwise.model, which = 1:6)
dwtest(stepwise.model)
```
```{r, message = F, warning = F}
summary(stepwise.model)
```

In questo terzo tentativo di regressione abbiamo ottenuto un R^2 = 0.87, quindi siamo riusciti a spiegare l'87% della variabilità di y (salesprice), il che è un buon incremento rispetto a prima, infatti quando si controlla lo scatterplot dei residui, si nota che il pattern di prima è sparito, ci sono ancora alcune non linearita o outlier sulla coda sinistra, che si notano anche nel qq plot. La distanza di Crook e la leva mostrano che non ci sono parametri con un alta distanza di Crook con anche varia Leva sui paraemtri del modello, il che è un buon risoltato.

Ho voluto cercare di ri-computare il modello usando solo i dati di vendite dove la SaleCondition era "Normal", quindi non c'erano vendite tra familiari, o vendite di appartamenti/case multiple, o assestamenti parziali delle caratteristiche delle case.

## Analisi del Dataset con solo Normal Sales

```{r, results = "hide", message = F, warning = F}
HP_normal <- HP[HP$SaleCondition == "Normal",]
HP_normal$Id <- NULL

categorical_vars <-
    names(HP_normal)[sapply(HP_normal, function(x)
        is.factor(x) | is.character(x))]
single_level_vars <-
    categorical_vars[sapply(HP_normal[categorical_vars], function(x)
        length(unique(x)) == 1)]
HP_normal <- HP_normal[,!names(HP_normal) %in% single_level_vars]
categorical_vars <-
    names(HP_normal)[sapply(HP_normal, function(x)
        is.factor(x) | is.character(x))]
HP_normal[categorical_vars] <-
    lapply(HP_normal[categorical_vars], as.factor)
numericVars <- which(sapply(HP_normal, is.numeric))
numericData <- HP_normal[, numericVars]
correlations <- cor(numericData, use = "pairwise.complete.obs")
correlationWithSalePrice <-
    sort(correlations[, 'SalePrice'], decreasing = TRUE)
topNumericPredictors <- names(correlationWithSalePrice)[2:11]
keyCategoricalVars <-
    c("Neighborhood", "BldgType", "HouseStyle", "OverallQual")
keyCategoricalVars <-
    keyCategoricalVars[keyCategoricalVars %in% names(HP_normal)]
encoded_data <- data.frame(model.matrix( ~ . - 1, HP_normal))
encoded_categoricalVars <-
    grep(paste(keyCategoricalVars, collapse = "|"),
         names(encoded_data),
         value = TRUE)
selected_predictors <-
    c(topNumericPredictors, encoded_categoricalVars)
X_selected <- encoded_data[, selected_predictors]
y <- encoded_data$SalePrice
simple.model <- lm(y ~ ., data = X_selected)
stepwise.model <-
    stepAIC(simple.model, direction = "both", trace = TRUE)
```
```{r, message = F, warning = F}
summary(stepwise.model)
```

### Valori dei residui vs fitted (solo Normal Sales )

```{r, message = F, warning = F}
residuals <- resid(stepwise.model)
fitted_values <- fitted(stepwise.model)

ggplot() +
    geom_point(aes(x = fitted_values, y = residuals), color = "blue") +
    geom_hline(yintercept = 0,
               color = "red",
               linetype = "dashed") +
    ggtitle("Residuals vs Fitted Values (Normal Sales Only)") +
    xlab("Fitted Values") +
    ylab("Residuals")
```

### Q-Q Plot dei residui (solo Normal Sales)

```{r, message = F, warning = F}
ggplot() +
    geom_qq(aes(sample = residuals)) +
    geom_qq_line(aes(sample = residuals), color = "red") +
    ggtitle("Q-Q Plot of Residuals (Normal Sales Only)")
```

### Resudui standard, leva e distanza di Cook (solo Normal Sales )

```{r, message = F, warning = F}
autoplot(stepwise.model, which = 1:6)
```

## Analili con Log(y) del Dataset con solo Normal Sales

```{r, results = "hide", message = F, warning = F}
y_transformed <- log(y)

simple.model <- lm(y_transformed ~ ., data = X_selected)
stepwise.model <-
    stepAIC(simple.model, direction = "both", trace = TRUE)
residuals <- resid(stepwise.model)
fitted_values <- fitted(stepwise.model)

ggplot() +
    geom_point(aes(x = fitted_values, y = residuals), color = "blue") +
    geom_hline(yintercept = 0,
               color = "red",
               linetype = "dashed") +
    ggtitle("Residuals vs Fitted Values") +
    xlab("Fitted Values") +
    ylab("Residuals")

ggplot() +
    geom_qq(aes(sample = residuals)) +
    geom_qq_line(aes(sample = residuals), color = "red") +
    ggtitle("Q-Q Plot of Residuals")

autoplot(stepwise.model, which = 1:6)
dwtest(stepwise.model)
```
```{r, message = F, warning = F}
summary(stepwise.model)
```

Il modello performa ancora meglio, con un R^2 di 0.89, quindi un ottima accuratezza sui dati di training con salescondition "Normal".
